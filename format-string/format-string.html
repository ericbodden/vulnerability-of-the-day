<h2>Uncontrolled Format String</h2>
<p>
	<b>Description. </b> See <a
		href="http://cwe.mitre.org/data/definitions/134.html">CWE-134</a>. In
	C, printing using
	<code>printf(str)</code>
	instead of
	<code>printf("%s", str)</code>
	results in the user being able to control the format string. This is
	especially egregious when you look at the
	<code>%x</code>
	and
	<code>%n</code>
	codes, which allow users to read and write arbirary bytes to arbitrary
	memory locations.
</p>
<p>
	<b>Examples:</b>
</p>
<ul>
	<li><a href="format-string.zip">format-string.zip</a>. Run <code>make</code>
		to see some interesting exploits. Also, be sure to check out what <code>read-memory.rb</code>
		does (requires <code>make</code> first)</li>
</ul>
<p>
	<b>Mitigations: </b>
</p>
<ul>
	<li>Just use a format string!</li>
	<li>Watch your compiler warnings, which look like: <code>warning:
			format not a string literal and no format arguments </code></li>
</ul>
<p>
	<b>Notes</b>
</p>
<ul>
	<li>The key that makes the <code>%x</code> code work is that
		printf is a varargs function. If you add more <code>%x</code> codes
		to the string, printf just starts reading memory locations from where
		it left off - right at the call stack.
	</li>
	<li>This one is just as severe as buffer overflow, as it can
		allow arbitrary remote code execution.</li>
	<li><a
		href="http://www.amazon.com/Buffer-Overflows-Format-String-Schwachstellen-Tobias-Klein/dp/3898641929/">Entire
			books</a> have been written on elaborate exploits of format string
		vulnerabilities</li>
</ul>