<h2>Insecure PRNGs</h2>
<p>
	<b>Description. </b> See <a
		href="http://cwe.mitre.org/data/definitions/338.html">CWE-338</a>.
	Most pseudo-random number generators (PRNGs) are not designed to be
	secure, and with improper management can be easily guessed by a
	variety of methods.
</p>
<p>
	<b>Examples:</b>
</p>
<ul>
	<li><a href="prngs.zip">prngs.zip</a>. DeckDealer is a simplified
		example of a card shuffling class where the PRNG was seeded by the
		time, and an outside program could just create a database of possible
		seeds and check the results.</li>
	<li>A famous example of this occurred in Debian distributions of
		OpenSSL, as described in depth <a
		href="http://digitaloffense.net/tools/debian-openssl/">here </a>.
	</li>
</ul>
<p>
	<b>Mitigations: </b>
</p>
<ul>
	<li>Use PRNGs that are designed to be secure: e.g. <code>java.util.SecureRandom</code>
		instead of <code>java.util.Random</code>.
	</li>
	<li>Don't use predictable seeds, such as:
		<ul>
			<li>Seeds that are reset consistently. Re-seeding doesn't make
				the PRNG any more secure (or "random").</li>
			<li>Millisecond time. In 100 years, there are only 3*10^12
				milliseconds, which a botnet can easily enumerate through.</li>
			<li>Nanosecond time. If attackers know roughly when you reset
				your seed, they can narrow down the space for guessing.</li>
			<li>Process IDs. Even smaller space than millisecond time.</li>
			<li>Anything else that can be guessed.</li>
		</ul>Instead, have the user set a secret token upon installation, and
		protect that secret token.
	</li>
</ul>
<p>
	<b>Notes</b>
</p>

<ul>
	<li>The need for secure PRNGs arises in many different
		situations, such as cryptographic seeds, multi-factor authentication
		mechanisms, and session tokens. In most cases, a broken PRNG has
		devastating effects (e.g. predicting all future session tokens)</li>
</ul>